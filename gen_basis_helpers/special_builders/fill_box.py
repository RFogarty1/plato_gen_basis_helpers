
import sympy

import plato_pylib.utils.supercell as supCellHelp

class GetCartCoordsToFillUpCellToNAtoms():

	def __init__(self, primCell):
		""" Initializer
		
		Args:
			primCell: (UnitCell) Represents primitive cell, cartesian co-ordinates for the callable function will be generated by duplicating and scaling this cell accordingly. Number of lattice sites in the cell are especially important; smaller number of sites will give more flexibility
				 
		"""
		self.primCell = primCell

	def getCartCoordsToFillUpCell(self, nAtoms, inpCell):
		self._checkAnglesSimilarEnough(self.primCell, inpCell)
		nLayersC = self._getNLayersInC(nAtoms,inpCell)
		nA,nB = self._getNumbImagesAB(nAtoms, nLayersC, inpCell)
		outCell = supCellHelp.superCellFromUCell(self.primCell, [nA,nB,nLayersC])
		outCell.lattParams = inpCell.lattParams	#Fractional co-ordinates dont move; but cartesian will.
		return outCell.cartCoords

	def _checkAnglesSimilarEnough(self, cellA, cellB, tolerance=1e-1):
		anglesA = cellA.getLattAnglesList()
		anglesB = cellB.getLattAnglesList()
		for angleA, angleB in zip(anglesA,anglesB):
			if abs(angleA-angleB)>tolerance:
				raise ValueError("Shape of primitive/input cell do not match; angles are {} and {}".format(anglesA,anglesB))

	def _getNLayersInC(self, nAtoms, inpCell):
		#1) Get the possible values we can use
		nPrimAtoms = len(self.primCell.cartCoords)
		divisors = sympy.divisors(nAtoms)
		possibleFactors = [int(x/nPrimAtoms) for x in divisors if x%nPrimAtoms==0]

		#2) Get an objective measure of the "goodness" of each value
		objFunctVals = list()
		inpC, primC = inpCell.lattParams["c"], self.primCell.lattParams["c"]
		perfectVal = inpC/primC
		for factor in possibleFactors:
			currVal = abs( perfectVal-factor )
			objFunctVals.append(currVal)

		#3) Choose the value to use (we choose the highest possible which gives a match within a tolerance). 
		tolerance = 0.1
		minObjFunct = min(objFunctVals)
		allowedFactors = list()
		for idx, objVal in enumerate(objFunctVals):
			if abs(objVal-minObjFunct)<tolerance:
				allowedFactors.append( possibleFactors[idx] )

		return max(allowedFactors)

	def _getNumbImagesAB(self, nAtoms, nLayers, inpCell):
		#1) Get the possible combinations of nA,nB
		nPrimCell = len(self.primCell.cartCoords)
		nPerLayer = int(nAtoms/nLayers)
		assert nAtoms%nLayers == 0
		dimProduct = int( nPerLayer / nPrimCell )
		assert nPerLayer%nPrimCell == 0
		factors = sympy.divisors(dimProduct)
		factorPairs = [ [int(dimProduct/x),x] for x in factors]

		#2) Get an objective function for how well these cells match the inpCell ab plane
		inpA, inpB = inpCell.lattParams["a"], inpCell.lattParams["b"]
		primA, primB = self.primCell.lattParams["a"], self.primCell.lattParams["b"]
		perfectA, perfectB = inpA/primA, inpB/primB
		objFunctVals = list()
		for factorCombo in factorPairs:
			errorA, errorB = abs(perfectA-factorCombo[0]), abs(perfectB-factorCombo[1])
			currVal = errorA + errorB
			objFunctVals.append(currVal)

		#3) Choose the value to use (we pick the one with highest n_a that gives a decent match within a tolerance)
		tolerance = 0.1
		minObjFunct = min(objFunctVals)
		allowedFactors = list()
		for idx, objVal in enumerate(objFunctVals):
			if abs(objVal-minObjFunct)<tolerance:
				allowedFactors.append( factorPairs[idx] )

		return max(allowedFactors, key=lambda x:x[0])


	def __call__(self, nAtoms, inpCell):
		return self.getCartCoordsToFillUpCell(nAtoms, inpCell)


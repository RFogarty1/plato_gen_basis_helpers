
import sympy

import plato_pylib.utils.supercell as supCellHelp


class GetOptimalCellDimsMappingPrimitiveCellToInpGeomBase():

	def _getPossibleCombinations(self,nSites, primCell):
		assert nSites%len(primCell.cartCoords) == 0
		numberPrimCells = int( nSites / len(primCell.cartCoords) )
		return getCommonTripletOfFactors(numberPrimCells)

	def __call__(self, nSites, primCell, inpCell):
		raise NotImplementedError("")


def getCommonTripletOfFactors(n):
	""" Get all factors a*b*c = n, where a,b,c and n are integers. Suspect this USUALLY works, not really 100% sure it will always get ALL the combinations
	
	Args:
		n: (integer)
			 
	Returns
		factors: (iter of len-3 iters) each entry is [a,b,c]
 
	"""
	#Step 1: Get (a*b)*c common factors, i.e. all PAIRS of factors
	divisors = sympy.divisors(n)
	factorPairs = [ [x,int(n/x)] for x in divisors]


	#Step 2: For each PAIR of factors we split the first (which we think of as a*b) into its unique factors
	tripleFactors = list()
	for fPair in factorPairs:
		currDivisors = sympy.divisors(fPair[0])
		currPairs = [ [x,int(fPair[0]/x)] for x in currDivisors ]
		currTriples = [ x + [fPair[1]] for x in currPairs ]
		tripleFactors.extend(currTriples)

	return tripleFactors


class CellFillerImproved():
	""" Callable class, see self.getCartCoordsToFillUpCell for the callable interface """

	def __init__(self, primCell, algorithm=None):
		""" Initializer
		
		Args:
			primCell: (UnitCell) Represents primitive cell, cartesian co-ordinates for the callable function will be generated by duplicating and scaling this cell accordingly. Number of lattice sites in the cell are especially important; smaller number of sites will give more flexibility
			algorithm: (GetOptimalCellDimsMappingPrimitiveCellToInpGeomBase object) f(nSites, primCell, inpCell)->[nA,nB,nC] Default algorithm is XXX.
				 
		"""
		self.primCell = primCell
		self.algorithm = algorithm if algorithm is not None else MapPrimToInpCellToMinimiseAverageLatticeParamDeviation()

	def getCartCoordsToFillUpCell(self, nSites, inpCell):
		self._checkAnglesSimilarEnough(self.primCell, inpCell)
		nA, nB, nC = self._getNumbImagesEachDim(nSites, inpCell)
		outCell = supCellHelp.superCellFromUCell(self.primCell, [nA,nB,nC])
		outCell.lattParams = inpCell.lattParams	#Fractional co-ordinates dont move; but cartesian will.
		return outCell.cartCoords

	def _checkAnglesSimilarEnough(self, cellA, cellB, tolerance=1e-1):
		anglesA = cellA.getLattAnglesList()
		anglesB = cellB.getLattAnglesList()
		for angleA, angleB in zip(anglesA,anglesB):
			if abs(angleA-angleB)>tolerance:
				raise ValueError("Shape of primitive/input cell do not match; angles are {} and {}".format(anglesA,anglesB))

	def _getNumbImagesEachDim(self, nSites, inpCell):
		return self.algorithm(nSites, self.primCell, inpCell)

	def __call__(self, nAtoms, inpCell):
		return self.getCartCoordsToFillUpCell(nAtoms, inpCell)



class MapPrimToInpCellToMinimiseAverageLatticeParamDeviation(GetOptimalCellDimsMappingPrimitiveCellToInpGeomBase):
	""" Picks the supercell to:
	a) Minimise the average value of sum( [abs(a_t-a)/a_t, abs(b_t-b)/b_t, abs(c_t-c)/c_t] ) where a_t is the target value of a (value on inpCell) while a is the actual value from the mapping
	b) If two (or more) possibilities are within self.diffTol then we attempt to maximise dimension of c, then b, then a ([1,2,3] is favored over [2,3,1]) which is favored over [3,2,1] """

	def __init__(self, diffTol=1e-2):
		self.diffTol = diffTol

	def __call__(self, nSites, primCell, inpCell):
		allPossible = self._getPossibleCombinations(nSites, primCell)
		allObjVals = list()

		#1) Figure out the objective function for EACH possible supercell
		targParams = inpCell.getLattParamsList()
		objVals = list()
		for combo in allPossible:
			currCell = supCellHelp.superCellFromUCell(primCell, combo)
			currLattParams = currCell.getLattParamsList()
			currObjVals = sum( [abs(targParam-actParam)/actParam for targParam,actParam in zip(targParams,currLattParams)] )
			objVals.append(currObjVals)

		#2) Figure out the best supercell parameters from the objective functions
		minVal = min(objVals)
		diffFromMinVals = [x-minVal for x in objVals]
		paramsWithinTolerance = [x for x,diffFromMin in zip(allPossible, diffFromMinVals) if diffFromMin<self.diffTol]

		#If some are tied, favor the one with highest c, then b then a
		outVal = sorted(paramsWithinTolerance)[0]

		return outVal


class CellFillerStandard():
	""" DEPRECATED: Use CellFillerImproved for a better algorithm. Easier to deprecate this than swap the algorithm out really
		Callable class, see self.getCartCoordsToFillUpCell for the callable interface
	"""

	def __init__(self, primCell):
		""" Initializer
		
		Args:
			primCell: (UnitCell) Represents primitive cell, cartesian co-ordinates for the callable function will be generated by duplicating and scaling this cell accordingly. Number of lattice sites in the cell are especially important; smaller number of sites will give more flexibility
				 
		"""
		self.primCell = primCell

	def getCartCoordsToFillUpCell(self, nAtoms, inpCell):
		self._checkAnglesSimilarEnough(self.primCell, inpCell)
		nLayersC = self._getNLayersInC(nAtoms,inpCell)
		nA,nB = self._getNumbImagesAB(nAtoms, nLayersC, inpCell)
		outCell = supCellHelp.superCellFromUCell(self.primCell, [nA,nB,nLayersC])
		outCell.lattParams = inpCell.lattParams	#Fractional co-ordinates dont move; but cartesian will.
		return outCell.cartCoords

	def _checkAnglesSimilarEnough(self, cellA, cellB, tolerance=1e-1):
		anglesA = cellA.getLattAnglesList()
		anglesB = cellB.getLattAnglesList()
		for angleA, angleB in zip(anglesA,anglesB):
			if abs(angleA-angleB)>tolerance:
				raise ValueError("Shape of primitive/input cell do not match; angles are {} and {}".format(anglesA,anglesB))

	def _getNLayersInC(self, nAtoms, inpCell):
		#1) Get the possible values we can use
		nPrimAtoms = len(self.primCell.cartCoords)
		divisors = sympy.divisors(nAtoms)
		possibleFactors = [int(x/nPrimAtoms) for x in divisors if x%nPrimAtoms==0]

		#2) Get an objective measure of the "goodness" of each value
		objFunctVals = list()
		inpC, primC = inpCell.lattParams["c"], self.primCell.lattParams["c"]
		perfectVal = inpC/primC
		for factor in possibleFactors:
			currVal = abs( perfectVal-factor )
			objFunctVals.append(currVal)

		#3) Choose the value to use (we choose the highest possible which gives a match within a tolerance). 
		tolerance = 0.1
		minObjFunct = min(objFunctVals)
		allowedFactors = list()
		for idx, objVal in enumerate(objFunctVals):
			if abs(objVal-minObjFunct)<tolerance:
				allowedFactors.append( possibleFactors[idx] )

		return max(allowedFactors)

	def _getNumbImagesAB(self, nAtoms, nLayers, inpCell):
		#1) Get the possible combinations of nA,nB
		nPrimCell = len(self.primCell.cartCoords)
		nPerLayer = int(nAtoms/nLayers)
		assert nAtoms%nLayers == 0
		dimProduct = int( nPerLayer / nPrimCell )
		assert nPerLayer%nPrimCell == 0
		factors = sympy.divisors(dimProduct)
		factorPairs = [ [int(dimProduct/x),x] for x in factors]

		#2) Get an objective function for how well these cells match the inpCell ab plane
		inpA, inpB = inpCell.lattParams["a"], inpCell.lattParams["b"]
		primA, primB = self.primCell.lattParams["a"], self.primCell.lattParams["b"]
		perfectA, perfectB = inpA/primA, inpB/primB
		objFunctVals = list()
		for factorCombo in factorPairs:
			errorA, errorB = abs(perfectA-factorCombo[0]), abs(perfectB-factorCombo[1])
			currVal = errorA + errorB
			objFunctVals.append(currVal)

		#3) Choose the value to use (we pick the one with highest n_a that gives a decent match within a tolerance)
		tolerance = 0.1
		minObjFunct = min(objFunctVals)
		allowedFactors = list()
		for idx, objVal in enumerate(objFunctVals):
			if abs(objVal-minObjFunct)<tolerance:
				allowedFactors.append( factorPairs[idx] )

		return max(allowedFactors, key=lambda x:x[0])


	def __call__(self, nAtoms, inpCell):
		return self.getCartCoordsToFillUpCell(nAtoms, inpCell)

